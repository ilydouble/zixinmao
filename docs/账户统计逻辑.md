# 账户统计逻辑说明

## 统计字段定义

根据需求，个人中心页面显示的统计数据定义如下：

### 1. 总订单
- **数据源**: `user.totalConsumption` 字段
- **含义**: 用户在数据库中存储的总消费金额
- **显示**: `¥{{userInfo.totalConsumption}}`

### 2. 总充值  
- **数据源**: `user.totalRecharge` 字段
- **含义**: 用户在数据库中存储的总充值金额
- **显示**: `¥{{userInfo.totalRecharge}}`

### 3. 总消费
- **数据源**: 计算所有订单金额总和
- **含义**: 所有已完成订单的金额总和（实时计算）
- **计算逻辑**: `sum(orders.amount) where status = 'completed'`
- **显示**: `¥{{userInfo.orderStats.totalConsumption}}`

### 4. 账户余额
- **计算公式**: `总充值 - 总消费`
- **含义**: 用户当前可用余额
- **显示**: `¥{{userInfo.balance}}`

### 5. 已完成订单数
- **数据源**: 计算已完成订单数量
- **含义**: 状态为 'completed' 的订单数量
- **显示**: `{{userInfo.orderStats.completedOrders}}`

## 技术实现

### 云函数计算逻辑

```javascript
// getUserInfo 云函数中的计算
function calculateOrderStats(orders) {
  const stats = {
    totalOrders: orders.length,
    completedOrders: 0,
    pendingOrders: 0,
    totalConsumption: 0 // 所有订单金额总和
  }

  orders.forEach(order => {
    if (order.status === 'completed') {
      stats.completedOrders++
      // 总消费 = 所有已完成订单的金额总和
      stats.totalConsumption += order.amount || 0
    } else if (order.status === 'pending' || order.status === 'processing') {
      stats.pendingOrders++
    }
  })

  return stats
}

function calculateActualBalance(user, orderStats) {
  const totalRecharge = user.totalRecharge || 0
  const totalConsumption = orderStats.totalConsumption || 0
  
  // 余额 = 总充值 - 总消费
  return Math.max(0, totalRecharge - totalConsumption)
}
```

### 前端显示逻辑

```xml
<!-- 账户余额 -->
<text class="balance-value">¥{{userInfo.balance}}</text>

<!-- 统计网格 -->
<view class="stats-grid">
  <!-- 总订单：使用数据库字段 -->
  <view class="stats-item">
    <text class="stats-value">¥{{userInfo.totalConsumption}}</text>
    <text class="stats-label">总订单</text>
  </view>
  
  <!-- 总充值：使用数据库字段 -->
  <view class="stats-item">
    <text class="stats-value">¥{{userInfo.totalRecharge}}</text>
    <text class="stats-label">总充值</text>
  </view>
  
  <!-- 总消费：使用计算值 -->
  <view class="stats-item">
    <text class="stats-value">¥{{userInfo.orderStats.totalConsumption}}</text>
    <text class="stats-label">总消费</text>
  </view>
  
  <!-- 已完成：使用计算值 -->
  <view class="stats-item">
    <text class="stats-value">{{userInfo.orderStats.completedOrders}}</text>
    <text class="stats-label">已完成</text>
  </view>
</view>
```

## 数据流程

### 1. 用户信息获取
```
用户请求 → getUserInfo云函数 → 查询用户表 → 查询订单表 → 计算统计 → 返回结果
```

### 2. 统计计算流程
```
1. 从数据库获取用户基础信息（totalRecharge, totalConsumption）
2. 查询用户所有订单
3. 计算实时统计数据：
   - 已完成订单数
   - 所有订单金额总和
4. 计算账户余额：totalRecharge - 实时总消费
5. 组装返回数据
```

### 3. 前端显示流程
```
页面加载 → 调用getUserInfo → 获取统计数据 → 更新页面显示
```

## 测试验证

### 测试数据创建
使用 `createTestOrders` 云函数创建测试订单：
- 充值订单：100元、200元
- 消费订单：15元、25元、15元、25元、15元
- 不同状态：completed、pending、processing

### 预期结果
- 总充值：300元
- 总消费：95元（所有已完成订单金额总和）
- 账户余额：205元（300 - 95）
- 已完成订单：5个

### 验证步骤
1. 测试页面 → "创建测试订单数据"
2. 个人中心 → 查看账户信息卡片
3. 验证各项统计数据是否正确

## 注意事项

### 1. 数据一致性
- `user.totalConsumption` 和 `user.totalRecharge` 是数据库存储的历史累计值
- `orderStats.totalConsumption` 是基于订单表实时计算的值
- 两者可能存在差异，以实时计算值为准

### 2. 性能考虑
- 订单查询按创建时间倒序排列
- 最近订单只取前5条
- 统计计算在云函数中进行，减少前端计算压力

### 3. 错误处理
- 订单查询失败时，统计数据默认为0
- 余额计算确保不为负数
- 前端显示时提供默认值兜底

## 后续优化

1. **缓存机制**: 对统计数据进行缓存，减少重复计算
2. **增量更新**: 订单变更时增量更新统计数据
3. **分页查询**: 订单数量大时使用分页查询
4. **实时同步**: 订单状态变更时实时更新余额
